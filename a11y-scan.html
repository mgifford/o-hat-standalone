<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Standalone A11y Scanner</title>
    <style>
        body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; line-height: 1.5; }
        #warning { background: #ffebee; border: 1px solid #ffcdd2; padding: 10px; color: #b71c1c; font-weight: bold; margin-bottom: 20px; border-radius: 4px; }
        .controls { background: #f5f5f5; padding: 15px; border-radius: 4px; margin-bottom: 20px; }
        .form-group { margin-bottom: 10px; }
        .form-row { display: flex; flex-wrap: wrap; gap: 10px; align-items: flex-end; margin-bottom: 10px; }
        .form-row > * { flex: 1 1 220px; }
        label { display: block; font-weight: bold; margin-bottom: 5px; }
        input[type="text"], input[type="number"], select, textarea { width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box; }
        textarea { min-height: 100px; }
        input[type="checkbox"] { margin-right: 5px; }
        button { background: #0056b3; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; margin-right: 8px; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        button.stop { background: #d32f2f; }
        .pill { display: inline-block; padding: 4px 12px; border: 1px solid #ccc; border-radius: 999px; font-size: 14px; }
        .pill.idle { background: #e0e0e0; }
        .pill.loading { background: #fff3cd; color: #856404; }
        .pill.scanning { background: #d1ecf1; color: #0c5460; }
        .pill.ok { background: #d4edda; color: #155724; }
        .pill.error { background: #f8d7da; color: #721c24; }
        #status { margin: 20px 0; font-weight: bold; }
        #log { white-space: pre-wrap; background: #f7f7f7; border: 1px solid #ddd; padding: 10px; height: 180px; overflow: auto; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size: 13px; }
        #results { margin-top: 30px; }
        .progress-stats { display: flex; gap: 20px; flex-wrap: wrap; margin-bottom: 10px; }
        .stat { font-weight: bold; }
        .stat-value { color: #0056b3; }
        .error { color: #d32f2f; }
        .success { color: #2e7d32; }
        .warning { color: #f57c00; }

        table { border-collapse: collapse; width: 100%; margin-top: 10px; }
        th, td { border: 1px solid #ddd; padding: 8px; vertical-align: top; text-align: left; }
        th { background: #f2f2f2; font-weight: bold; }
        details { margin: 4px 0; }
        summary { cursor: pointer; font-weight: bold; }
        .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size: 13px; }
        pre { background: #2d2d2d; color: #f8f8f2; padding: 8px; overflow-x: auto; border-radius: 4px; }

        #gate-screen { position: fixed; top:0; left:0; width:100%; height:100%; background:white; display:flex; justify-content:center; align-items:center; z-index: 1000; }
        .hidden { display: none !important; }
        iframe { width: 1px; height: 1px; position: absolute; left: -99999px; top: 0; border: 0; }
        #dropZone {
            border: 2px dashed #0056b3;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            color: #0056b3;
            background: #f0f7ff;
            margin-bottom: 20px;
            transition: background 0.2s;
            cursor: pointer;
        }
        #dropZone.dragover {
            background: #dceeff;
            border-color: #004494;
        }
        
        /* New Report UI Styles */
        .report-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .report-card { background: white; border: 1px solid #ddd; padding: 20px; border-radius: 8px; text-align: center; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .report-card h3 { font-size: 12px; text-transform: uppercase; color: #666; margin: 0 0 10px 0; letter-spacing: 0.5px; }
        .report-card .number { font-size: 36px; font-weight: bold; color: #333; display: block; margin-bottom: 5px; }
        .report-card .sub { font-size: 12px; color: #888; }
        .bg-red { border-top: 4px solid #d32f2f; }
        .bg-blue { border-top: 4px solid #0277bd; }
        .bg-gray { border-top: 4px solid #757575; }

        .section-title { font-size: 24px; border-bottom: 2px solid #eee; padding-bottom: 10px; margin: 40px 0 20px; }
        
        .subsection-title { font-size: 16px; margin: 25px 0 15px; padding: 8px 12px; border-radius: 4px; font-weight: bold; }
        .subsection-title.must-fix { background: #ffebee; color: #c62828; border-left: 4px solid #d32f2f; }
        .subsection-title.good-to-fix { background: #e1f5fe; color: #01579b; border-left: 4px solid #0277bd; }

        .issue-group { border: 1px solid #e0e0e0; margin-bottom: 10px; border-radius: 6px; background: white; }
        .issue-header { background: #f9f9f9; padding: 12px 15px; display: flex; justify-content: space-between; align-items: center; list-style: none; }
        .issue-header:hover { background: #f0f0f0; }
        .issue-header::-webkit-details-marker { display: none; }
        .issue-title { font-weight: bold; font-size: 16px; color: #333; }
        .issue-meta { font-size: 13px; color: #666; text-align: right; }
        .issue-body { padding: 15px; border-top: 1px solid #e0e0e0; background: #fff; }
        
        .top-page-row { display: flex; justify-content: space-between; padding: 12px 15px; border-bottom: 1px solid #eee; background: white; }
        .top-page-row:last-child { border-bottom: none; }
        .top-page-url { font-family: ui-monospace, monospace; color: #0056b3; text-decoration: none; }
        .top-page-url:hover { text-decoration: underline; }
        .count-badge { background: #eee; padding: 2px 8px; border-radius: 12px; font-size: 12px; font-weight: bold; color: #555; }
        .count-badge.high { background: #ffebee; color: #c62828; }

        .scan-footer { margin-top: 50px; border-top: 1px solid #eee; padding-top: 20px; color: #666; font-size: 14px; }
    </style>
</head>
<body>

<div id="gate-screen">
    <div style="text-align:center;">
        <h2>Access Denied</h2>
        <p>Please provide a valid token parameter.</p>
        <p style="font-size: 14px; color: #666;">Example: ?token=A11Y-SECRET</p>
    </div>
</div>

<div id="app" class="hidden">
    <div id="warning">
        <h2>⚠️ SECURITY WARNING</h2>
        <p><strong>Authenticated Context Risk:</strong> This scanner runs with <em>your</em> browser cookies. If you are logged into a CMS/Admin panel, this scanner can access protected pages.</p>
        <p><strong>Server Load Risk:</strong> Scanning many pages rapidly can slow down your server. A minimum delay of 1000ms is enforced.</p>
        <p><strong>Do not deploy this to Production without password protection (Basic Auth/VPN).</strong></p>
    </div>

    <h1>Standalone Accessibility Scanner</h1>
    <p><a href="index.html">&larr; Back to Home</a></p>

    
    <div class="controls">
        <div class="form-group">
            <label for="sourceType">Scan Source</label>
            <select id="sourceType">
                <option value="sitemap">Sitemap (sitemap.xml)</option>
                <option value="custom">Custom List (below)</option>
                <option value="files">Local Directory (Drag/Drop)</option>
            </select>
        </div>
        
        <div class="form-group" id="sitemapInputGroup">
            <label for="sitemapPath">Sitemap Path</label>
            <input type="text" id="sitemapPath" value="sitemap.xml">
        </div>

        <div class="form-group hidden" id="customListGroup">
             <label for="customUrlList">URLs (one per line)</label>
             <textarea id="customUrlList"></textarea>
        </div>
        
        <div id="dropZone" class="hidden">
            <h3>Drag & Drop Folder Here</h3>
            <p>Drag a folder containing HTML files to scan them directly.</p>
            <div id="dropStatus">No files selected</div>
        </div>

        <div class="form-row">
            <div class="form-group">
                <label for="pathPrefix">Path Prefix Filter (optional)</label>
                <input type="text" id="pathPrefix" placeholder="/blog">
            </div>

            <div class="form-group">
                <label for="excludeStr">Exclude Substrings (comma-separated)</label>
                <input type="text" id="excludeStr" placeholder="admin, login, logout">
            </div>
        </div>

        <div class="form-row">
            <div class="form-group">
                <label for="maxPages">Max Pages</label>
                <input type="number" id="maxPages" value="50" min="1" max="5000">
            </div>

            <div class="form-group">
                <label for="delayMs">Delay (ms) - Minimum 1000ms</label>
                <input type="number" id="delayMs" value="1000" min="1000">
            </div>

            <div class="form-group">
                <label for="timeoutMs">Timeout per page (ms)</label>
                <input type="number" id="timeoutMs" value="20000" min="1000" max="120000">
            </div>
        </div>

        <div class="form-row">
            <div class="form-group">
                <label for="axePath">Axe Script Path</label>
                <input type="text" id="axePath" value="assets/axe.min.js">
            </div>

            <div class="form-group">
                <label>
                    <input type="checkbox" id="includePasses">
                    Include passes in results
                </label>
                <label>
                    <input type="checkbox" id="includeIncomplete">
                    Include incomplete in results
                </label>
            </div>
        </div>

        <div style="margin-top: 10px;">
            <button id="startBtn">Start Scan</button>
            <button id="stopBtn" class="stop" disabled>Stop</button>
            <button id="exportBtn" disabled>Export JSON</button>
            <button id="exportCsvBtn" disabled>Export CSV</button>
            <span id="statusPill" class="pill idle">idle</span>
        </div>
    </div>

    <fieldset style="border: 1px solid #ccc; padding: 12px; margin-bottom: 12px;">
        <legend>Progress</legend>
        <div class="progress-stats">
            <div class="stat">Loaded URLs: <span id="loadedCount" class="stat-value">0</span></div>
            <div class="stat">Scanned: <span id="scannedCount" class="stat-value">0</span></div>
            <div class="stat">Pages with violations: <span id="pagesWithViolations" class="stat-value">0</span></div>
            <div class="stat">Total violation instances: <span id="totalViolations" class="stat-value">0</span></div>
        </div>
        <div id="log" role="log" aria-live="polite" aria-atomic="false"></div>
    </fieldset>

    <div id="status">Ready</div>

    <div id="results"></div>
</div>

<iframe id="scanFrame" aria-hidden="true"></iframe>

<script>
    const REQUIRED_TOKEN = "A11Y-SECRET";
    const TOKEN_PARAM = "token";
    const params = new URLSearchParams(window.location.search);
    const token = params.get(TOKEN_PARAM);
    if (token === REQUIRED_TOKEN) {
        document.getElementById('gate-screen').classList.add('hidden');
        document.getElementById('app').classList.remove('hidden');
    }

    const els = {
        sourceType: document.getElementById('sourceType'),
        sitemapPath: document.getElementById('sitemapPath'),
        customList: document.getElementById('customUrlList'),
        sitemapGroup: document.getElementById('sitemapInputGroup'),
        customGroup: document.getElementById('customListGroup'),
        dropZone: document.getElementById('dropZone'),
        dropStatus: document.getElementById('dropStatus'),
        pathPrefix: document.getElementById('pathPrefix'),
        excludeStr: document.getElementById('excludeStr'),
        maxPages: document.getElementById('maxPages'),
        delayMs: document.getElementById('delayMs'),
        timeoutMs: document.getElementById('timeoutMs'),
        axePath: document.getElementById('axePath'),
        includePasses: document.getElementById('includePasses'),
        includeIncomplete: document.getElementById('includeIncomplete'),
        startBtn: document.getElementById('startBtn'),
        stopBtn: document.getElementById('stopBtn'),
        exportBtn: document.getElementById('exportBtn'),
        exportCsvBtn: document.getElementById('exportCsvBtn'),
        statusPill: document.getElementById('statusPill'),
        status: document.getElementById('status'),
        loadedCount: document.getElementById('loadedCount'),
        scannedCount: document.getElementById('scannedCount'),
        pagesWithViolations: document.getElementById('pagesWithViolations'),
        totalViolations: document.getElementById('totalViolations'),
        log: document.getElementById('log'),
        results: document.getElementById('results'),
        iframe: document.getElementById('scanFrame')
    };

    let urlList = [];
    let stopRequested = false;
    let runData = null;
    let fileRegistry = new Map(); // path -> File object
    let axeScriptContent = null; // cache for axe script content

    function setPill(text, cls) {
        els.statusPill.textContent = text;
        els.statusPill.className = `pill ${cls || ""}`.trim();
    }
    
    // Drag & Drop Handlers
    els.dropZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        els.dropZone.classList.add('dragover');
    });

    els.dropZone.addEventListener('dragleave', () => {
        els.dropZone.classList.remove('dragover');
    });

    els.dropZone.addEventListener('drop', async (e) => {
        e.preventDefault();
        els.dropZone.classList.remove('dragover');
        
        fileRegistry.clear();
        els.dropStatus.textContent = "Scanning directory...";
        const items = e.dataTransfer.items;
        
        if (items) {
            for (let i = 0; i < items.length; i++) {
                const item = items[i].webkitGetAsEntry();
                if (item) {
                    await traverseFileTree(item);
                }
            }
        }
        
        const count = fileRegistry.size;
        els.dropStatus.textContent = `Found ${count} HTML file${count !== 1 ? 's' : ''}. Ready to scan.`;
        if (count > 0) {
            loadUrls();
        }
    });

    function traverseFileTree(item, path = "") {
        return new Promise((resolve) => {
            if (item.isFile) {
                if (item.name.endsWith('.html')) {
                    item.file((file) => {
                        // Create a simulated path
                        const fullPath = path + item.name;
                        // Use a fake protocol so URL() parsing works if needed, or just plain string
                        // We'll use a unique key
                        const key = "file://" + fullPath;
                        fileRegistry.set(key, file);
                        resolve();
                    });
                } else {
                    resolve();
                }
            } else if (item.isDirectory) {
                const dirReader = item.createReader();
                const readEntries = () => {
                    dirReader.readEntries(async (entries) => {
                        if (entries.length === 0) {
                            resolve();
                        } else {
                            const params = entries.map(e => traverseFileTree(e, path + item.name + "/"));
                            await Promise.all(params);
                            // Continue reading until empty (standard behavior for readEntries)
                            readEntries();
                        }
                    });
                };
                readEntries();
            }
        });
    }

    function log(line) {
        const t = new Date().toISOString().replace("T", " ").replace("Z", "");
        els.log.textContent += `[${t}] ${line}\n`;
        els.log.scrollTop = els.log.scrollHeight;
    }

    function setStatus(text, pill) {
        els.status.textContent = text;
        if (pill) setPill(text, pill);
    }

    function sleep(ms) {
        return new Promise(r => setTimeout(r, ms));
    }

    function sameOrigin(url) {
        const u = new URL(url, window.location.href);
        return u.origin === window.location.origin;
    }

    async function fetchSitemapUrls(path) {
        const res = await fetch(path, { credentials: "include" });
        if (!res.ok) throw new Error(`Failed to fetch sitemap: ${res.status} ${res.statusText}`);
        const xmlText = await res.text();
        const parser = new DOMParser();
        const doc = parser.parseFromString(xmlText, "application/xml");
        const locNodes = [...doc.getElementsByTagName("loc")];
        const urls = locNodes.map(n => n.textContent?.trim()).filter(Boolean);
        if (!urls.length) throw new Error("No <loc> entries found in sitemap.");
        return urls;
    }

    function parseCustomList() {
        return els.customList.value.split('\n').map(u => u.trim()).filter(Boolean);
    }

    function applyFilters(urls) {
        // Normalize prefix so both "/blog" and "blog" work against paths like "/standalone/blog/post1.html".
        const rawPrefix = (els.pathPrefix.value || "").trim();
        const prefix = rawPrefix ? (rawPrefix.startsWith('/') ? rawPrefix : `/${rawPrefix}`) : "";
        const maxPages = parseInt(els.maxPages.value, 10) || 50;
        const excludes = (els.excludeStr.value || "").split(',').map(s => s.trim()).filter(Boolean);
        const filtered = [];

        for (const raw of urls) {
            const u = new URL(raw, window.location.href);
            if (prefix) {
                // Accept if path starts with the prefix (exact) OR contains it after "/standalone" to handle the local folder prefix.
                const path = u.pathname;
                if (!(path.startsWith(prefix) || path.startsWith(`/standalone${prefix}`))) continue;
            }
            let blocked = false;
            for (const ex of excludes) {
                if (u.href.includes(ex)) { blocked = true; break; }
            }
            if (blocked) continue;
            filtered.push(u.href);
            if (filtered.length >= maxPages) break;
        }
        return filtered;
    }

    function summarize(resultsByUrl) {
        let pagesWithViolations = 0;
        let totalViolations = 0;
        for (const res of Object.values(resultsByUrl)) {
            const violations = res.violations || [];
            if (violations.length > 0) pagesWithViolations++;
            for (const v of violations) totalViolations += (v.nodes || []).length;
        }
        return { pagesWithViolations, totalViolations };
    }

    function esc(s) {
        return String(s).replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;");
    }

    function renderUrlDetails(res) {
        if (res.error) {
            return `<span class="error">${esc(res.error)}</span>`;
        }
        const violations = res.violations || [];
        if (!violations.length) return '<span class="success">No violations</span>';
        let html = '';
        for (const v of violations) {
            const nodeCount = v.nodes?.length || 0;
            html += `<details>
                <summary><span class="error">${esc(v.id)}</span> (${nodeCount}) - ${esc(v.help || "")}</summary>
                <div class="mono">Impact: ${esc(v.impact || "unknown")}</div>
                ${v.helpUrl ? `<div><a href="${esc(v.helpUrl)}" target="_blank" rel="noopener">rule help</a></div>` : ""}
                <ul>`;
            for (const n of (v.nodes || [])) {
                const target = (n.target || []).join(', ');
                const summary = n.failureSummary ? esc(n.failureSummary) : '';
                const htmlSnippet = n.html ? esc(n.html) : '';
                html += `<li>
                    <div class="mono">Target: ${esc(target)}</div>
                    ${summary ? `<div>${summary}</div>` : ""}
                    ${htmlSnippet ? `<pre class="mono">${htmlSnippet}</pre>` : ""}
                </li>`;
            }
            html += '</ul></details>';
        }
        return html;
    }

    function renderResults(resultsByUrl) {
        const entries = Object.entries(resultsByUrl);
        if (!entries.length) {
            els.results.innerHTML = '<p style="text-align:center;color:#666;">No results yet.</p>';
            return;
        }

        // 1. Calculate Stats
        const totalPages = entries.length;
        let pagesWithIssues = 0;
        let mustFixCount = 0;
        let goodToFixCount = 0;
        
        // Group issues
        const allIssues = new Map(); // id -> { rule, nodes: [], pages: Set() }

        for (const [url, res] of entries) {
            const violations = res.violations || [];
            if (violations.length > 0) pagesWithIssues++;

            for (const v of violations) {
                const impact = v.impact || 'minor';
                if (['critical', 'serious'].includes(impact)) mustFixCount += (v.nodes || []).length;
                else if (['moderate', 'minor'].includes(impact)) goodToFixCount += (v.nodes || []).length;
                
                if (!allIssues.has(v.id)) {
                    allIssues.set(v.id, { ...v, nodes: [], pages: new Set() });
                }
                const record = allIssues.get(v.id);
                record.pages.add(url);
                for (const n of (v.nodes || [])) {
                    record.nodes.push({ ...n, pageUrl: url });
                }
            }
        }
        
        const groupedIssues = Array.from(allIssues.values());
        
        // 2. Generate HTML
        let html = `
            <div style="margin-bottom: 30px; border-bottom: 2px solid #eee; padding-bottom: 20px;">
                <div style="display:flex; justify-content:space-between; align-items:flex-start;">
                   <div>
                       <h2 style="margin-top:0;">Accessibility Scan Report</h2>
                       <p style="color:#666; margin:5px 0;">
                           Date: ${new Date().toLocaleString()} · <span style="font-weight:bold;">${totalPages} Pages Scanned</span>
                       </p>
                   </div>
                   <div>
                       <a href="#" onclick="exportCsv(); return false;" class="pill scanning" style="text-decoration:none; padding:8px 16px;">Download CSV</a>
                   </div>
                </div>
            </div>

            <div class="report-grid">
                <div class="report-card">
                    <h3>Pages Scanned</h3>
                    <span class="number">${totalPages}</span>
                    <span class="sub">Targets processed</span>
                </div>
                <div class="report-card ${pagesWithIssues > 0 ? 'bg-red' : 'bg-gray'}">
                    <h3>Pages with Issues</h3>
                    <span class="number">${pagesWithIssues}</span>
                    <span class="sub">${totalPages > 0 ? Math.round((pagesWithIssues/totalPages)*100) : 0}% of pages</span>
                </div>
                <div class="report-card bg-red">
                    <h3>Must Fix</h3>
                    <span class="number">${mustFixCount}</span>
                    <span class="sub">Critical / Serious impacts</span>
                </div>
                <div class="report-card bg-blue">
                    <h3>Good to Fix</h3>
                    <span class="number">${goodToFixCount}</span>
                    <span class="sub">Moderate / Minor impacts</span>
                </div>
            </div>

            <h2 class="section-title">Top pages to review</h2>
            <div style="border:1px solid #ddd; border-radius:8px; overflow:hidden; margin-bottom: 30px;">
                ${renderTopPages(entries)}
            </div>

            <h2 class="section-title">Issues grouped by impact</h2>
            ${renderIssuesByImpact(groupedIssues)}
            
            <div class="scan-footer">
                <h3>About this scan</h3>
                <p>
                    Date: ${new Date().toLocaleString()}<br>
                    User Agent: ${navigator.userAgent}<br>
                    Tool: Standalone A11y Scanner
                </p>
            </div>
        `;

        els.results.innerHTML = html;
    }

    function renderTopPages(entries) {
        // Sort by total violation count (nodes)
        const sorted = entries.map(([url, res]) => {
            const count = (res.violations||[]).reduce((acc, v) => acc + (v.nodes||[]).length, 0);
            return { url, count };
        }).sort((a,b) => b.count - a.count).slice(0, 5); // Start with top 5

        if (sorted.length === 0) return '<div style="padding:15px;">No pages scanned yet.</div>';

        return sorted.map(p => `
            <div class="top-page-row">
                <a href="${p.url}" target="_blank" class="top-page-url">${p.url}</a>
                <span class="count-badge ${p.count > 0 ? 'high' : ''}">${p.count} issues</span>
            </div>
        `).join('');
    }

    function renderIssuesByImpact(issues) {
        const mustFix = issues.filter(i => ['critical', 'serious'].includes(i.impact));
        const goodToFix = issues.filter(i => ['moderate', 'minor'].includes(i.impact));
        
        let html = '';
        
        if (mustFix.length) {
            html += `<h3 class="subsection-title must-fix">Must Fix (${mustFix.reduce((a,i)=>a+i.nodes.length,0)} occurrences)</h3>`;
            html += mustFix.map(renderIssueGroup).join('');
        }
        
        if (goodToFix.length) {
            html += `<h3 class="subsection-title good-to-fix">Good to Fix (${goodToFix.reduce((a,i)=>a+i.nodes.length,0)} occurrences)</h3>`;
            html += goodToFix.map(renderIssueGroup).join('');
        }

        if (!mustFix.length && !goodToFix.length) {
             html += '<p>No issues found.</p>';
        }
        
        return html;
    }

    function renderIssueGroup(issue) {
        // Group nodes by URL for display
        const nodesByUrl = {};
        for (const n of issue.nodes) {
            if (!nodesByUrl[n.pageUrl]) nodesByUrl[n.pageUrl] = [];
            nodesByUrl[n.pageUrl].push(n);
        }

        return `
            <details class="issue-group">
                <summary class="issue-header">
                    <div>
                        <span class="issue-title">${esc(issue.id)}</span>
                        <span style="font-weight:normal; margin-left: 10px; color:#555;">${esc(issue.help)}</span>
                    </div>
                    <div class="issue-meta">
                        ${issue.nodes.length} instances · ${issue.pages.size} pages
                        <span class="pill ${['critical','serious'].includes(issue.impact) ? 'error' : 'scanning'}" style="margin-left:8px;">${issue.impact}</span>
                    </div>
                </summary>
                <div class="issue-body">
                    <p style="margin-top:0;">
                        ${esc(issue.description)} 
                        ${issue.helpUrl ? `<a href="${issue.helpUrl}" target="_blank" rel="noopener">Learn more</a>` : ''}
                    </p>
                    ${Object.entries(nodesByUrl).map(([url, nodes]) => `
                        <div style="margin-bottom: 15px;">
                            <strong><a href="${url}" target="_blank">${url}</a></strong> (${nodes.length} nodes)
                            ${nodes.map(n => `
                                <div style="margin-left: 15px; border-left: 2px solid #ddd; padding-left: 10px; margin-top:5px; background:#fafafa; padding:8px;">
                                    <div class="mono" style="font-size:12px; color:#555; margin-bottom:4px;">Target: ${esc(n.target && n.target.join(' '))}</div>
                                    ${n.html ? `<pre style="margin:0; font-size:11px; white-space:pre-wrap;">${esc(n.html)}</pre>` : ''}
                                    <div style="color:#d32f2f; font-size:12px; margin-top:4px;">${esc(n.failureSummary)}</div>
                                </div>
                            `).join('')}
                        </div>
                    `).join('')}
                </div>
            </details>
        `;
    }

    function makeIframe(url) {
        const iframe = els.iframe;
        iframe.src = 'about:blank';
        iframe.removeAttribute('style');
        return iframe;
    }

    function waitForLoad(iframe, timeoutMs) {
        return new Promise((resolve, reject) => {
            let done = false;
            const t = setTimeout(() => {
                if (done) return;
                done = true;
                reject(new Error('Timed out waiting for iframe load.'));
            }, timeoutMs);
            iframe.onload = () => {
                if (done) return;
                done = true;
                clearTimeout(t);
                resolve();
            };
        });
    }

    function injectScript(iframe, srcOrContent, isContent = false) {
        return new Promise((resolve, reject) => {
            const doc = iframe.contentDocument;
            if (!doc) return reject(new Error('No iframe.contentDocument available (blocked or not loaded).'));
            if (iframe.contentWindow && iframe.contentWindow.axe) return resolve();
            const s = doc.createElement('script');
            if (isContent) {
                s.textContent = srcOrContent;
                // Inline scripts run immediately when appended
            } else {
                s.src = srcOrContent;
                s.onload = () => resolve();
                s.onerror = () => reject(new Error('Failed to load axe script in iframe.'));
            }
            doc.head.appendChild(s);
            if (isContent) resolve();
        });
    }

    async function runAxeInFrame(iframe, options) {
        const w = iframe.contentWindow;
        const d = iframe.contentDocument;
        if (!w || !d) throw new Error('iframe window/document not accessible.');
        if (!w.axe) throw new Error('axe not present in iframe.');
        return await w.axe.run(d, options);
    }

    async function loadUrls() {
        setStatus('Loading URLs...', 'loading');
        els.startBtn.disabled = true;
        els.exportBtn.disabled = true;
        els.exportCsvBtn.disabled = true;
        els.results.innerHTML = '';
        els.log.textContent = '';

        let urls = [];
        if (els.sourceType.value === 'sitemap') {
            urls = await fetchSitemapUrls(els.sitemapPath.value.trim() || 'sitemap.xml');
        } else if (els.sourceType.value === 'custom') {
            urls = parseCustomList();
        } else if (els.sourceType.value === 'files') {
            urls = Array.from(fileRegistry.keys());
            if (urls.length === 0) {
                 log("No files loaded. Please drag and drop a folder first.");
            }
        }

        const filtered = applyFilters(urls);
        urlList = filtered;
        els.loadedCount.textContent = String(urlList.length);
        log(`URLs discovered: ${urls.length}, after filters: ${urlList.length}`);


        if (!urlList.length) {
            setStatus('No URLs to scan.', 'error');
            return;
        }

        setStatus('Ready', 'idle');
        els.startBtn.disabled = false;
    }

    async function startScan() {
        stopRequested = false;
        els.startBtn.disabled = true;
        els.stopBtn.disabled = false;
        els.exportBtn.disabled = true;
        els.exportCsvBtn.disabled = true;

        // Refresh URLs from current inputs so the user does not need to pre-load.
        await loadUrls();
        if (!urlList.length) return;

        runData = {
            runId: `manual-${Date.now()}`,
            startedAt: new Date().toISOString(),
            toolVersion: 'standalone-1.0',
            mode: 'standalone',
            config: {
                sitemapPath: els.sitemapPath.value.trim(),
                pathPrefix: els.pathPrefix.value.trim(),
                excludeStr: els.excludeStr.value.trim(),
                maxPages: parseInt(els.maxPages.value, 10) || 50,
                delayMs: Math.max(parseInt(els.delayMs.value, 10) || 0, 1000),
                timeoutMs: parseInt(els.timeoutMs.value, 10) || 20000,
                axePath: els.axePath.value.trim(),
                includePasses: !!els.includePasses.checked,
                includeIncomplete: !!els.includeIncomplete.checked
            },
            targets: [...urlList],
            resultsByUrl: {}
        };

        window.__lastRun = runData;

        // Pre-fetch axe script if in file mode
        if (els.sourceType.value === 'files' && !axeScriptContent) {
             setStatus('Loading axe-core...', 'loading');
             try {
                 const axeUrl = new URL(runData.config.axePath, window.location.href).toString();
                 const res = await fetch(axeUrl);
                 if (!res.ok) throw new Error("Failed to load axe script from " + axeUrl);
                 axeScriptContent = await res.text();
             } catch (e) {
                 setStatus('Error loading axe', 'error');
                 log('Fatal: ' + e.message);
                 return;
             }
        }

        els.scannedCount.textContent = '0';
        els.pagesWithViolations.textContent = '0';
        els.totalViolations.textContent = '0';
        setStatus('Scanning...', 'scanning');
        log('Starting scan.');

        const axeOptions = {
            resultTypes: ['violations']
                .concat(runData.config.includePasses ? ['passes'] : [])
                .concat(runData.config.includeIncomplete ? ['incomplete'] : [])
        };

        let scanned = 0;
        for (const url of urlList) {
            if (stopRequested) break;

            const isLocal = fileRegistry.has(url);

            if (!isLocal && !sameOrigin(url)) {
                runData.resultsByUrl[url] = { error: 'Skipping cross-origin URL', violations: [] };
                scanned++;
                els.scannedCount.textContent = String(scanned);
                const { pagesWithViolations, totalViolations } = summarize(runData.resultsByUrl);
                els.pagesWithViolations.textContent = String(pagesWithViolations);
                els.totalViolations.textContent = String(totalViolations);
                renderResults(runData.resultsByUrl);
                log(`SKIP cross-origin: ${url}`);
                continue;
            }

            log(`Scanning: ${url}`);
            const iframe = makeIframe(url);
            
            try {
                if (isLocal) {
                    const file = fileRegistry.get(url);
                    const html = await file.text();
                    iframe.removeAttribute('src');
                    iframe.srcdoc = html;
                } else {
                    iframe.removeAttribute('srcdoc');
                    iframe.src = url;
                }

                await waitForLoad(iframe, runData.config.timeoutMs);
                await sleep(250); // small settle time for SPAs
                
                if (isLocal) {
                    await injectScript(iframe, axeScriptContent, true);
                } else {
                    await injectScript(iframe, new URL(runData.config.axePath, window.location.href).toString());
                }

                const res = await runAxeInFrame(iframe, axeOptions);
                runData.resultsByUrl[url] = res;
                scanned++;
                els.scannedCount.textContent = String(scanned);
                const { pagesWithViolations, totalViolations } = summarize(runData.resultsByUrl);
                els.pagesWithViolations.textContent = String(pagesWithViolations);
                els.totalViolations.textContent = String(totalViolations);
                renderResults(runData.resultsByUrl);
                log(`Done: ${url} (rules: ${(res.violations || []).length})`);
            } catch (e) {
                runData.resultsByUrl[url] = { error: String(e), violations: [] };
                scanned++;
                els.scannedCount.textContent = String(scanned);
                renderResults(runData.resultsByUrl);
                log(`ERROR: ${url} -> ${e}`);
            } finally {
                iframe.src = 'about:blank';
                iframe.removeAttribute('srcdoc');
            }

            if (stopRequested) break;
            if (runData.config.delayMs > 0) await sleep(runData.config.delayMs);
        }

        runData.finishedAt = new Date().toISOString();
        window.__lastRun = runData;


        if (stopRequested) {
            setStatus('Stopped by user.', 'error');
            log('Stopped by user.');
        } else {
            setStatus('Scan Complete', 'ok');
            log('Scan finished.');
        }

        els.stopBtn.disabled = true;
        els.exportBtn.disabled = false;
        els.exportCsvBtn.disabled = false;
        els.startBtn.disabled = false;
    }

    function stopScan() {
        stopRequested = true;
        els.stopBtn.disabled = true;
        log('Stop requested. Will finish current page.');
    }

    function exportJson() {
        if (!runData) return;
        const blob = new Blob([JSON.stringify(runData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `axe-scan-${new Date().toISOString().replaceAll(':', '-')}.json`;
        a.click();
        URL.revokeObjectURL(url);
    }

    function mapSeverityLabel(impact) {
        const mapping = {
            critical: 'Must Fix',
            serious: 'Must Fix',
            moderate: 'Good to Fix',
            minor: 'Good to Fix'
        };
        return mapping[impact] || 'Manual Review Required';
    }

    function escapeCsvField(field) {
        if (field === null || field === undefined) return '""';
        const s = String(field);
        return `"${s.replace(/"/g, '""')}"`;
    }

    function exportCsv() {
        if (!runData) return;
        const headers = [
            "customFlowLabel","deviceChosen","scanCompletedAt","severity","issueId",
            "issueDescription","wcagConformance","url","pageTitle","context",
            "howToFix","axeImpact","xpath","learnMore"
        ];

        let csvContent = headers.map(escapeCsvField).join(',') + "\n";
        const finishedAt = runData.finishedAt || new Date().toISOString();

        for (const [url, data] of Object.entries(runData.resultsByUrl || {})) {
            const violations = data.violations || [];
            for (const v of violations) {
                const nodes = v.nodes || [];
                const severity = mapSeverityLabel(v.impact);
                for (const node of nodes) {
                    const row = [
                        "None", // customFlowLabel
                        "Desktop", // deviceChosen
                        finishedAt, // scanCompletedAt
                        severity, // severity
                        v.id || '', // issueId
                        v.description || v.help || '', // issueDescription
                        v.tags ? v.tags.join(',') : '', // wcagConformance
                        url, // url
                        data.title || '', // pageTitle (not collected in standalone)
                        node.html || '', // context
                        node.failureSummary || '', // howToFix
                        v.impact || '', // axeImpact
                        node.target ? node.target.join(', ') : '', // xpath/selector
                        v.helpUrl || '' // learnMore
                    ];
                    csvContent += row.map(escapeCsvField).join(',') + "\n";
                }
            }
        }

        const blob = new Blob([csvContent], { type: 'text/csv' });
        const dlUrl = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = dlUrl;
        a.download = `axe-scan-${new Date().toISOString().replaceAll(':', '-')}.csv`;
        a.click();
        URL.revokeObjectURL(dlUrl);
    }

    els.sourceType.addEventListener('change', () => {
        els.customGroup.classList.add('hidden');
        els.sitemapGroup.classList.add('hidden');
        els.dropZone.classList.add('hidden');

        if (els.sourceType.value === 'custom') {
            els.customGroup.classList.remove('hidden');
        } else if (els.sourceType.value === 'files') {
            els.dropZone.classList.remove('hidden');
        } else {
            els.sitemapGroup.classList.remove('hidden');
        }
    });

    els.startBtn.addEventListener('click', () => startScan().catch(err => {
        setStatus('Error', 'error');
        log(String(err));
        els.stopBtn.disabled = true;
        els.startBtn.disabled = false;
    }));

    els.stopBtn.addEventListener('click', stopScan);
    els.exportBtn.addEventListener('click', exportJson);
    els.exportCsvBtn.addEventListener('click', exportCsv);

    // Auto-load URLs on open for convenience
    loadUrls().catch(err => {
        setStatus('Error loading URLs', 'error');
        log(String(err));
    });
</script>

</body>
</html>
